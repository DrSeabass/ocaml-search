Still have to do the whole implementation
Problem space is described in
	"Finding Optimal Solutions to Rubik's Cube Using Pattern Databases"

Korf holds the center cubies on each face fixed.  Essentially, you
can't rotate the cube in your hand while solving it.  The rest of the
problem he represents as an array of 20 elements.  There are 8 corner
cubies and 12 edge cubies, giving rise to the 20 elements.  Each of
the 8 edges can be represented by a triple of colors, or a single int,
he uses a similar trick on the edges.

Moves allow for either a 90 degree or 180 degree rotation of any
facing, either clockwise or counter clockwise.  Branching factor 18

B.F. can be reduced in two ways.  First, no facing may be twisted
twice in a row, since you could have always gotten the desired
orientation in a single move.  BF --> 15

Next, an ordering is imposed over the faces which can be turned.
Moves between opposite faces compose naturally, so turning one, then
the other is the same as turning the other, then the first.  thus a
weak ordering is imposed over these moves.


Naming convention over the faces -
  Top, Bottom
  Front, Rear,
  Left, Right

Naming convention over the turns
  90_clock, 90_counter, 180

Thus, a specific move becomes
  Top, 90_clock
  Bottom, 180
  etc


Weak ordering -
     Top before Bottom
     Front before Rear
     Left Before Right

Then, just do a brute force tree out to a fixed depth, and check to
make sure your numbers to table 1 in Korf's paper.  These represent
NON-UNIQUE nodes generated by a brute force search out to a depth of
18.  You'll probably not be doing that far out (numbers are the huge)


It isn't clear
