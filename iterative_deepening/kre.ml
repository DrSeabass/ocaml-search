(** The Korf-Reid-Edelkamp method for determining the number of nodes
    generated by an IDA* search at a given bound.

    @author eaburns
    @since 2009-06-19
*)

type t = {
  h_model : Nb.t;
  (* Model of the heuristic distribution given the type of a node. *)
  h_max : int;
  (* Maximum heuristic value. *)
  ntypes : int;
  (* Number of types. *)
}


let make_no_smoothing h_max ntypes =
  (** Create a new KRE distribution learner. *)
  {
    h_model = Nb.make_no_smoothing 1 (ntypes - 1) (h_max + 1);
    h_max = h_max;
    ntypes = ntypes;
  }


let make_with_smoothing h_max ntypes =
  (** Create a new KRE distribution learner. *)
  {
    h_model = Nb.make_add_1_smoothing 1 (ntypes - 1) (h_max + 1);
    h_max = h_max;
    ntypes = ntypes;
  }


let of_naive_bayes nb =
  (** [of_naive_bayes nb] creates a KRE model from a naive bayes
      learner. *)
  {
    h_model = nb;
    h_max = nb.Nb.nclasses - 1;
    ntypes = nb.Nb.nfeatures + 1;
  }


let train model inst =
  (** [train model inst] trains the distribution [model] on the instance
      [inst].  [inst] is a 3-tuple (instance, h value, type). *)
  let _, h, t = inst in
    Nb.train model.h_model (h, [| t |])


let learn_distribution h_max ntypes make rand_inst =
  (** [learn_distribution h_max ntypes make rand_inst] learns a
      new distribution of heuristic values for instances generated
      with the [rand_inst] function. [make] is the function that makes
      the model. *)
  let model = make h_max ntypes in
    begin try
      while true do
	train model (rand_inst ())
      done;
    with End_of_file -> ()
    end;
    model


let save model chan =
  (** [save model chan] saves the given heuristic model to the given
      channel. *)
  Marshal.to_channel chan model []


let load chan =
  (** [load chan] restores a saved model from the given channel. *)
  (Marshal.from_channel chan : t)


let ninstances rand_inst num =
  (** [ninstances rand_inst num] gets [num] random instances, created
      with the [rand_inst] function. When [num] instances have been
      generated an End_of_file exception is raised. *)
  let left = ref num in
    (fun () ->
       if !left mod 100_000 = 0 then Verb.pr Verb.always "%d\n%!" !left;
       if !left = 0
       then raise End_of_file
       else begin
	 decr left;
	 rand_inst ()
       end)


let prob_of_h_given_t model t h =
  (** [prob_of_h_given_t model h t] gives the probability that a node
      has an h-value of [h] or less given that it is of type [t]. *)
  let p_for_h h = Nb.prob model.h_model [| t |] h in
  let rec do_sum h =
    if h < 0
    then 0.0
    else (p_for_h h) +. (do_sum (h - 1))
  in
    if h >= model.h_max
    then 1.0
    else do_sum h


let e model n c =
  (** [e model n c] is approximately the number of nodes that IDA*
      will expand when the cost bound is [c]. *)
  let sum_types d =
    (* sums the percent of fertile nodes of each type at a given
       depth *)
    let probs =
      Array.init
	model.ntypes
	(fun t -> prob_of_h_given_t model t (c - d))
    and nums = n d
    in let sum = Vector.dot nums probs in
      Verb.pr Verb.debug "%d: " d;
      Wrarray.iter2
	(fun n p -> Verb.pr Verb.debug "%f *. %f, " n p)
	nums
	probs;
      Verb.pr Verb.debug "%f\n" sum;
      sum
  in
  let rec sum_depths d =
    (* sums the number of nodes at a given depth and below. *)
    if d = 0
    then 1.0
    else (sum_types d) +. (sum_depths (d - 1))
  in
    sum_depths c


let e_wtd_avg model wts n c =
  (** [e_wtd_avg model wts n c] computes a weighted average over
      all of the types of starting states. *)
  let vec = Array.init model.ntypes (fun t -> e model (n t) c) in
    Wrarray.iter2 (fun vl wt -> Verb.pr Verb.debug "%f *. %f\n" vl wt) vec wts;
    (Vector.dot vec wts) /. (Vector.sum wts)


(************************************************************)
(* Computing the number of nodes at a depth of a search     *)
(************************************************************)

let nnodes adj init_counts depth =
  (** [nnodes adj init_counts adj depth] is the number of nodes of
      each type at the given depth.  [init_counts] is the number of
      nodes possible at depth 1. *)
  assert (depth > 0);
  let vec = ref init_counts in
    for i = 2 to depth do
      vec := Matrix.mulf adj !vec;
    done;
    !vec


let equilibrium_fractions adj init_counts depth=
  (** [equilibrium_fractions adj init_counts depth] computes the
      equilibrium fractions at [depth] given [init_counts], the number
      of each type of state at depth 1 and [adj] the adjacency
      matrix. *)
  let vec = nnodes init_counts adj depth in
  let sum = Array.fold_left (+.) 0.0 vec in
    Array.map (fun vl -> vl /. sum) vec

(*
  Local Variables:
  compile-command: "ocm use"
  End:
*)
